컬럼 패밀리 데이터베이스
====

## 빅테이블

* 개발자가 동적으로 컬럼을 제어할 수 있다.
* 데이터 값이 로우 식별자, 컬럼 이름, 타임스탬프로 인덱싱 되어있다.
* 데이터 모델러와 개발자가 데이터의 저장 위치를 제어할 수 있다.
* 로우의 읽기와 쓰기는 원자 단위로 처리된다
* 로우는 정렬된 순서대로 유지 관리 된다.



### 동적으로 제어 가능한 컬럼

동적 컬럼



### 인덱싱 : 로우 식별자, 컬럼명, 타임스탬프

* 로우 식별자 : 관계형 데이터베이스의 Primary Key 와 유사. 로우를 고유하게 식별함
* 컬럼 명 : 컬럼 하나를 고유하게 식별하는 역할
* 타임스탬프 : 컬럼 값의 버전을 식별하는 역할
  * 빅테이블은 새로운 값을 쓸 때 이전 값을 덮어쓰지 않음. 새로운 값을 타임스탬프와 함께 추가함



### 데이터의 저장 위치 제어

항상 함께 조회되는 데이터일 경우 물리적으로도 함께 묶어서 저장하는 것이 효율적임.

컬럼패밀리를 이용하여 데이터를 저장하면 같은 패밀리끼리 컬럼들을 함께 저장해놓기 때문에 단일 데이터 블록만 읽어도 조회가 가능하다.



### 읽기/쓰기 원자성

모든 컬럼을 대상으로 하거나 전혀 아니거나 둘 중 하나! 성공/실패! 일부만 쓰는 일은 없엉



### 정렬 순서대로 로우 관리하기

정렬 순서에 따라 로우를 관리한다. 범위 질의가 자연스럽게 수행될 수 있다.

ex) 일자별로 정렬해서 저장해두면 별도로 정렬하지 않아도 범위 질의가 가능. (인덱스도 필요X)





## 용어

* 로우 : 여러개의 컬럼 패밀리로 이루어져 있다.
* 컬럼
* 컬럼 패밀리



## 설계

컬럼패밀리 데이터베이스 설계시에는 아래와 같은 사항들을 숙지해야한다!

* 조인 대신 비정규화
* 값이 없는 컬럼 사용하기
* 컬럼 이름과 컬럼 값을 사용해 데이터 저장하기
* 단일 로우를 이용한 엔터티 모델
* 로우 키에서 핫스팟 회피
  * 핫스팟 : 작업이 정체되는 것. 소수의 서버에서 많은 작업을 수행할 때. 병목현상 같은..
* 적당한 수의 컬럼 값 버전 유지
* 컬럼 값에서 복잡한 데이터 구조 회피
  * 문서 데이터베이스에서는 중첩된 오브젝트를 흔히 사용하지만 컬럼 패밀리에서는 지양하는 것이 좋다.

### 인덱스

#### 주요 인덱스 (Primary Index)

테이블 로우 키에 대한 인덱스

* 컬럼 패밀리 데이터베이스 시스템에서 자동으로 관리함

#### 보조 인덱스 (Secondary Index) 

하나 혹은 그 이상의 컬럼 값으로 생성한 인덱스

* 모든 컬럼 패밀리 데이터베이스 시스템에서 자동으로 관리하지는 않음. 하지만 조합/선택할 수 있도록은 제공한다.

##### 자동으로 관리되는 보조인덱스 : 테이블을 보조인덱스로 사용했을때보다 가벼움.
* 자동 보조 인덱스를 사용하지 않아야 할 때 : 성능이 오히려 떨어질 수 있음
  * 컬럼에 distinct 값이 적을 때 : 카디널리티(cardinality)가 적을때
  * 컬럼에 고유 값이 많을 때 (distinct 값이 너무 많을 때) : 인덱스를 읽어오는 시간이나 테이블을 검색해서 읽어오는 시간이나 비슷하거나 더 소요되는 경우가 생김...ㅋ
  * 컬럼 값이 비어 있는 경우가 많을 때

##### 테이블을 이용한 보조 인덱스

직접 인덱스를 만들어 사용하는 방법으로서 아래와 같은 경우에 사용하면 좋다.

* 데이터베이스 시스템에서 자동 관리해주지 않는 경우
* 컬럼에 distinct 값이 많을 경우

각 테이블의 로우키를 새로 만든 테이블의 로우키와 컬럼이름으로 치환하여 사용하는 방법이다.

직접 인덱스를 만든 것이기 때문에 관리도 직접 해야 한다 :

* 기준 테이블이 변경될 때 마다 테이블을 갱신하는 방법
  * 언제나 최신 데이터를 유지할 수 있음
  * 앱에서 쓰기 작업을 두번이나 해야함 => 지연시간 발생함
* 주기적으로 인덱스용 테이블을 갱신하는 batch job을 만드는 방법
  * 기존 쓰기작업에 추가적인 부하를 주지 않음
  * 데이터가 일치하지 않을 수 있음

