# 00_개요

데이터베이스의 역사와 NoSQL의 탄생 배경을 살펴보며 철학을 이해하자!



※ 개인적으로 이해한 내용을 적은 것이므로 잘못되었거나 부족한 내용이 있을 수 있습니다.

# NoSQL?

> 'SQL을 사용하지 않는다.', 'SQL만 있는 것이 아니다.'

* 분산처리, 고정되지 않은 스키마, 고가용성, 고확장성
* 키-값 / 도큐먼트 / 컬럼패밀리 / 그래프



# 목차

* [데이터베이스 관리 시스템의 역사](#데이터베이스-관리-시스템의-역사)
* [분산 시스템과 NoSQL 데이터베이스의 종류](#NoSQL-데이터베이스의-종류)



# 데이터베이스 관리 시스템의 역사

## 1. 초기 데이터베이스 관리 시스템

파일 시스템, 데이터베이스 시스템

* 플랫 파일 데이터 관리 시스템 : 데이터 관리의 초기 형태
* 계층형 데이터 관리 시스템
* 네트워크 데이터 관리 시스템

### 1.1. 플랫 파일 데이터 관리 시스템

데이터 세트를 플랫 파일로 관리하는 시스템. 디스크/자기테이프 등의 장기 기억 저장장치에 저장하는 방식. 

단일 레코드에 단일 엔티티가 결합된 형태로 데이터 저장

#### 특징 및 한계점

* 물리적 제약 존재
* 플랫파일을 사용하는 프로그램이 데이터의 구조를 결정
* 중복데이터 발생 가능
* 데이터 구조가 변할 수 있다
* 권한 설정이 어렵다 : 부서별로 보여지는 데이터가 다르게 하려면 하나 더 만들어야 함.
* 데이터 일관성이 훼손될 가능성 존재

### 1.2. 계층형 데이터 모델 시스템

플랫 파일 데이터 관리 시스템의 한계점 중, **검색의 비효율성**을 극복하기 위해 고안된 시스템.

부모-자식 계층구조 (1:N)

#### 특징 및 한계점

* 1:N 인 경우 효율적 
  * N:M 인 경우는 비효율 :  데이터 복제가 이루어져야 하기 때문
* 중복데이터 발생 필요
* 데이터 일관성이 훼손될 가능성 존재
* 데이터 집계시 오류 발생 가능성 존재

### 1.3. 네트워크 데이터 관리 시스템

계층형 모델의 한계점을 극복하기 위해 고안된 시스템

**그래프 형태의 N:M 계층구조**

* 네트워크 데이터 모델 : 스키마, 데이터베이스

#### 구조

서로 연결된 데이터 레코드로 구성

* 노드(node) : 데이터 레코드
* 엣지(edge) : 연결 정보
* 그래프(graph) : 노드와 엣지의 묶음
* 스키마(schema) : 다른 노드와 연결할 수 있는 종류의 노드. 노드간 유효한 관계(valid relation)을 정의함
* 데이터베이스(database) : 스키마 구조에 따라 실제 데이터가 저장되는 곳

#### 특징 및 한계점

* 단방향 비순환 그래프
* 설계, 관리가 어렵다
  * 노드 연결 구조에 따라 성능이 크게 차이날 수 있다
* 스키마가 변경되면 데이터베이스에 접근하는 프로그램도 수정되어야 한다

### 1.4. 전반적인 한계점

초기 데이터 관리 시스템들의 한계점을 정리해보자면 다음과 같다.

* 중복 데이터
* 보안기능 구현의 어려움 : 취약한 보안
* 비효율적인 탐색 : 느린 검색 속도
* 데이터베이스에 접근하는 프로그램 코드 관리의 어려움
  * 데이터베이스의 논리 구성과 물리 저장구조가 독립적이지 않기 때문



## 2. 관계형 데이터베이스 (RDB)

데이터 구조의 논리구성을 물리적인 저장구조와 분리. 데이터 비일관성 문제 해결.

### 특징

* 데이터 관리를 위한 언어인 SQL을 공통언어로 사용하도록 설계

### RDMS의 구조

* 스토리지 관리 프로그램
  * 장기 기억 저장 장치
* 메모리 관리 프로그램
* 데이터 사전 : 데이터베이스를 구성하는 여러가지 요소에 대한 정보를 포함함
  * 스키마, 테이블, 컬럼, 인덱스, 제약조건, 뷰
* 질의 언어
  * 데이터 정의 언어, 데이터 조작 언어

### RDBMS를 사용하는 애플리케이션의 구조

RDBMS를 사용하여 개발된 애플리케이션은 일반적으로 다음과 같은 구조를 가진다.

* 사용자 인터페이스
* 비즈니스 로직
* 데이터베이스 코드

### 한계점

대부분의 경우 거의 완벽한 시스템으로 사용되었지만, 최근 개인화된 데이터가 증가함에 따라 빅데이터화된 정보들을 처리하는데에는 한계가 있었다.

큰 규모의 데이터와 극도로 많은 수의 사용자를 대상으로 작업하는 앱 개발시에는 다음과 같은 사항들이 지원되어야 했다.

* 대용량 데이터의 읽기와 쓰기 작업
* 빠른 응답시간
* 높은 가용성

#### 해결하기 위한 방법들

* 수직적 확장 : CPU, 추가메모리, 저장장치 업그레이드 등
  * 비용 많이 듦... 임시방편....
* 비정규화(denormalization)
* 서버 여러대에 하나의 RDB를 사용 : 관리의 어려움 존재 / 트랜잭션 비용 증가



## 3. NoSQL 데이터베이스

전자 상거래와 소셜 미디어의 기하급수적인 성장으로 인해 데이터가 점점 커지기 시작했다. 더이상 관계형 데이터베이스로는 대용량 데이터를 관리하기 어려워졌다.

### 대용량 데이터 관리 시스템의 중요한 특징들

확장성, 비용, 유연성, 가용성

#### 확장성

크게 변화하는 작업 부하량에 대한 요구 사항을 효율적으로 충족시키는 능력.

* **스케일 업** : 프로세서, 메모리, 네트워크 대역폭 추가 등의 하드웨어/소프트웨어 적인 스펙을 업그레이드 한다. (수직적 확장)
  * 확장 시 운영 중지 시간(downtime)이 존재할 수 있음.
* **스케일 아웃** : 트래픽이 증가하면 서버를 증설하여 부하를 처리한다. 트래픽이 감소하면 증설했던 서버를 내린다. (수평적 확장)

상황에 따라 필요한 만큼의 서버만 추가/제거할 수 있는 **스케일 아웃**이 좀 더 유연한 방법이라고 할 수 있다.

#### 비용

NoSQL 데이터베이스 대부분이 오픈소스이다. 

#### 유연성

관계형 데이터베이스에서는 테이블, 컬럼 등을 크게 변경이 일어나지 않게끔 기존에 미리 정의하고 설계하여야 한다. NoSQL 데이터베이스에서는 설계의 변경 없이 테이블 구조를 변경할 수 있다. 즉, 고정된 테이블 구조가 필요하지 않다. 필요할 때에 동적으로 변경할 수 있다.

#### 가용성

NoSQL 데이터베이스는 서버를 여러개 사용할 수 있기 때문에 무정지 데이터베이스로서 사용할 수 있다. 하나의 서버가 중지되어도 다른 서버가 처리할 수 있기 때문. (주서버-백업서버...)



## 4. 결론

NoSQL이 RDB의 빅데이터를 처리하는 것에 대한 한계점으로 인해 출현하게 되었지만 RDB를 완벽하게 대체 할 수는 없다. NoSQL과 RDB는 **상호 보완적**으로 사용되어야 한다.



# NoSQL 데이터베이스의 종류

NoSQL 데이터베이스는 하나 이상의 서버를 사용할 수 있도록 설계되어있다. 즉, 분산 시스템을 구축할 수 있도록 설계 되어있다. 이에 따라 분산시스템에서 발생할 수 있는 문제들을 어떻게 해결하는지 살펴보자.

## 1. 분산 데이터베이스에서의 데이터 관리

### 데이터베이스가 수행해야 하는 기능

영구적인 데이터 저장, 데이터 일관성 유지, 데이터 가용성 확보

#### 영구적인 데이터 저장

데이터를 장기 기억 저장장치에 저장하여 영구적으로 보존한다.

#### 데이터 일관성 유지

동시성 이슈가 발생할 수 있기 때문에 단일 작업으로 묶어 처리하도록 한다. (관계형의 경우)

#### 데이터 가용성 확보

언제든지 사용할 수 있어야 한다. 백업 서버를 둬서 주 서버가 다운되었을 때 백업할 수 있도록 하자.

* 2단계 커밋 (2PC, 2 Phase Commit) : 백업 서버에까지 쓰기가 완료되어야 완료를 리턴
  * 백업 서버 개수에 따라 비용 증가, 쓰기시간 증가

## 2. 분산시스템에서는?

### 가용성과 일관성

어플리케이션의 성격에 따라 가용성, 일관성의 우선순위가 달라질 수 있다.

일관성보다 가용성이나 속도가 우선시되어야 하는 경우에는 분산 시스템에 모두 쓰여질 때까지 대기하지 않고바로 가용되도록 하는 것이 나을 수 있다. 예) 쇼핑 장바구니 등...

### 응답시간/일관성/지속성 간의 균형 맞추기

#### NoSQL 데이터베이스의 특징

* **결과적 일관성(eventual consistency)** : 일시적으로 다른 값을 가지게 되지만 결국에는 모든 복사본이 같은 값을 갖게 된다.
* **쿼럼(quorum)** : 반드시 응답해야 하는 서버의 수? 뭔가 설명이 부실 (보통 3이상의 홀수로..) [참고](http://bcho.tistory.com/622)
* **구성 임계값(configurable threshold)** : 서버의 최소 단위
  * 읽기 임계값 : 응답시간과 일관성 사이의 균형 (일관성을 유지하는 서버의 최소 단위..)
    * 보통 홀수로.. 1,3,5...
    * 읽기 임계값이 3이면, 서버 5대 중 3대가 같은 응답을 하면 그 즉시 반환
  * 쓰기 임계값 : 응답시간과 지속성 사이의 균형 (지속성을 유지하는 서버의 최소 단위..)
    * 보통 2이상으로...
    * 쓰기 임계값이 3이면, 서버 5대 중 3대에 동일 값이 쓰여지면 그 즉시 완료처리 (나머지 2대에도 나중에 쓰여지지만 언제쓰여질지 모름) => 쓰기 처리된 서버가 고장나거나 다운되면 데이터 소실 => 지속성이 떨어진다

### CAP : 일관성, 가용성, 파티셔닝

**분산데이터베이스는 CAP를 동시에 가질 수 없다.** - 에릭 브루어

* 일관성 (Consistency) : 서버 간 일관된 데이터를 유지
* 가용성 (Availability) : 질의에 대한 응답을 제공
* 파티션 보호(허용) (Partition protection) : 둘 이상의 데이터베이스 서버가 연결된 네트워크에 문제가 생기더라도 이 서버들은 여전히 일관된 데이터를 갖고 있다.
  * LAN 환경에서는 거의 일어나지 않음

> 실용성 측면에서 말하자면 데이터베이스 애플리케이션 설계자는 파티셔닝으로 발생하는 문제에 신경 쓰기보다는 일관성과 가용성 사이에서 균형을 잡도록 설계해야 한다.

## 3. ACID와 BASE

* ACID : 관계형 데이터베이스의 네가지 속성
* BASE : NoSQL데이터베이스의 4가지 속성

### ACID : 원자성, 일관성, 고립성, 지속성

* A (Atomicity, 원자성) : 더는 나눠지지 않는 단위. 모든 단계가 완료되거나 모두 완료되지 않거나 해야한다!
* C (Consistency, 일관성) : 데이터의 무결성을 지킨다
* I (Isolation, 고립성) : 완료되기 전까지는 외부에 노출되지 않는다
* D (Durability, 지속성) : 데이터는 영구적으로 저장된다 (영구저장매체)

### BASE : 기본적인 가용성, 소프트 상태, 결과적 일관성

* BA (Basically Available, 기본적인 가용성) : 장애허용과 비슷

* S (Soft State, 소프트 상태) : 데이터가 더 최신 상태인 데이터로 덮여쓰여진다

  > 일반적인 컴퓨터 과학에서의 소프트 상태 : 새로 고쳐지지 않으면 데이터가 소실된다

* E (Eventually Consistent, 결과적 일관성) : 일관성이 없는 상태가 있을 수 있다. 하지만 결국에는 (결과적으로는) 일관성이 보장된다.

  * 단조 읽기 일관성 (monotonic read consistency) : 이전 데이터를 **절대로** 받을 일이 없다. read-your-writes consistency 와는 다르게 다른 프로세스에서도 보장됨.
  * 단조 쓰기 일관성 (monotonic write consistency) : 명령어들이 실행된 순서대로 처리되는 것을 보장한다.
  * [인과적 일관성 (causal consistency)](https://en.wikipedia.org/wiki/Consistency_model#Causal_Consistency) :  **인과 관계가 있는** 쓰기 연산의 순서를 보장한다. (모든 프로세스내에서) "인과 관계"에 대한 정의는 링크 참고...
  * [최신 데이터 읽기 일관성 (read-your-writes consistency)](https://en.wikipedia.org/wiki/Consistency_model#Read-your-writes_Consistency) : 쓰기 요청을 한 프로세스와 동일 프로세스에서는 언제나 최신 데이터로 읽혀지는 것을 보장한다.
  * 세션 일관성 (session consistency) : 세션이 살아있는 동안은 최신 데이터 읽기 일관성을 보장한다.

## 4. NoSQL 데이터베이스의 네가지 유형

확장성, 가용성, 일관성,파티션허용, 지속성 사이에서의 균형을 잡는 것이 키포인트!

### 4.1. 키-값 데이터베이스

가장 간단한 형태. 저장과 조회라는 최소한의 원칙에 따라 만들어짐.

* 키 : namespace 내에서 고유한 값이어야 한다
  * 키-값 데이터베이스에서는 일반적으로 데이터베이스 1 : 이름공간 1 임
  * 데이터베이스 1 : 이름공간 N => 버킷
* 값 : 키와 함께 저장되는 데이터.
* RDB 와의 차이점 : 테이블X, 스키마/컬럼/제약조건 X, 조인X, 외부키X, 질의언어X

### 4.2. 문서 데이터베이스

데이터 저장시 키-값 방식을 사용하지만 **값을 문서(JSON, XML 등의 형태)로 저장**함!

* 문서 : 단일 문서에 여러 속성을 저장
* 문서 질의 : 키-값에서도 값을 JSON 형태로 넣을 수 있지만 조회시 항상 키를 이용해야 한다. 하지만 문서 데이터베이스는 질의 언어를 이용해 값으로도 조회 가능!
* RDB 와의 차이점 
  * 고정된/미리 정의된 스키마X => 유연성
  * 문서 중첩 및 리스트화 가능 => 조인 불필요

### 4.3. 컬럼패밀리 데이터베이스

![](https://www.tutorialspoint.com/cassandra/images/cassandra_column_family.jpg)

* 컬럼 : 기본적인 스토리지 단위. 이름-값
* 로우 : 한 무리의 컬럼.
  * 각 로우별로 다른 컬럼을 가질 수 있음. 많은 컬럼을 가질 수 있도록 설계되어있어 컬럼 집합, 수퍼 컬럼집합을 가질 수 있음.
* RDB 와의 차이점
  * 고정된/미리 정의된 스키마X (테이블X)
  * 테이블 조인X
  * 비정규화. 모든 정보를 가능하면 하나의 로우에 넣도록 한다.
  * SQL 질의와 유사한 질의언어 지원

### 4.4. [그래프 데이터베이스](https://whatis.techtarget.com/definition/graph-database)

근접한 객체를 모델링할 목적으로 설계된 데이터베이스

![](https://itknowledgeexchange.techtarget.com/overheard/files/2014/01/Graph-database-sketch.jpg)

* 노드 (=: vertex (정점)) : 식별자와 여러속성을 가진 객체
* 관계 (=: edge (엣지)) : 두 노드간의 링크. 두 노드 사이의 관계에 대한 속성
* RDB 와의 차이점
  * 경로를 따라가야 하는 경우 처리 속도가 매우 효율적이다.